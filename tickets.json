{
  "metadata": {
    "version": "1.0.0",
    "last_updated": "2025-09-13T22:12:51Z",
    "next_id": 35,
    "project": "napkinwire"
  },
  "tickets": [
    {
      "id": "TICKET-001",
      "title": "Implement Claude usage analyzer from log files",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T01:35:57Z",
      "updated_at": "2025-09-12T05:09:20Z",
      "description": "Complete the stub in mcp/usage_analysis.py to analyze Claude Desktop logs and track API usage patterns, window resets, and model usage",
      "requirements": [
        "Parse Claude Desktop log files from %APPDATA%/Claude/logs or %LOCALAPPDATA%/Claude/logs",
        "Extract message timestamps and identify model used (Opus vs Sonnet)",
        "Detect rate limit messages and session boundaries",
        "Calculate usage windows (5 hours every 5 hours pattern)",
        "Track burn rate for different models",
        "Identify when window resets occur",
        "Return current window status and estimated remaining time"
      ],
      "acceptance_criteria": [
        "Successfully finds and parses Claude log files",
        "Accurately identifies usage patterns and window resets",
        "Returns dict with window_started, time_elapsed, estimated_remaining, messages_this_window",
        "Handles missing or malformed log files gracefully",
        "Performance: analyzes logs in under 2 seconds"
      ],
      "files_affected": [
        "mcp/usage_analysis.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-002",
      "title": "Port config.py to YAML with safe loading and validation",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T01:38:35Z",
      "updated_at": "2025-09-12T16:50:00Z",
      "description": "Replace hardcoded config.py with a YAML configuration file that supports safe loading, validation, and environment overrides",
      "requirements": [
        "Create config.yaml with paths section (tickets_path, logs_path, project_root)",
        "Use PyYAML with safe_load to prevent code injection",
        "Implement ConfigManager class with validation",
        "Support environment variable overrides (e.g. NAPKINWIRE_TICKETS_PATH)",
        "Add config schema validation using pydantic or dataclasses",
        "Include example.config.yaml for reference",
        "Handle missing config gracefully with sensible defaults",
        "Log config loading for debugging without stdout pollution"
      ],
      "acceptance_criteria": [
        "All hardcoded paths moved to config.yaml",
        "YAML loads without security vulnerabilities using safe_load",
        "Config validates required fields on load",
        "Graceful fallback to defaults if config missing",
        "Environment variable override support (NAPKINWIRE_CONFIG)",
        "Config hot-reload detection for development mode"
      ],
      "files_affected": [
        "config.py",
        "config.yaml",
        "main.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-003",
      "title": "Add MCP tool for Claude usage analysis with summary and detailed modes",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T01:45:56Z",
      "updated_at": "2025-09-12T05:09:36Z",
      "description": "Create MCP tool that leverages the existing usage analysis logic from usage_analysis.py to provide usage reports at different detail levels",
      "requirements": [
        "Import and use existing analyze_usage() function from usage_analysis.py",
        "Add parameter detail_level with options: summary, detailed, both",
        "Summary format: current window status, time remaining, messages this session, current burn rate",
        "Detailed format: last 5 sessions, model usage breakdown, peak usage times, rate limit events, recommendations",
        "Both format: summary section followed by detailed section",
        "Return dict with clear structure based on detail level",
        "Format timestamps in human-readable format",
        "Include helpful context like 'You have ~2.5 hours remaining' instead of just numbers"
      ],
      "acceptance_criteria": [
        "Tool successfully analyzes logs using existing usage_analysis.py logic",
        "Summary mode returns concise stats in under 1 second",
        "Detailed mode provides comprehensive usage patterns",
        "Both mode combines summary and detailed cleanly",
        "Handles missing or empty logs gracefully",
        "Returns user-friendly formatted output",
        "No stdout pollution or MCP communication issues"
      ],
      "files_affected": [
        "main.py",
        "mcp/usage_analysis.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-004",
      "title": "Create project awareness tool with file tree and documentation extraction",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T05:10:58Z",
      "updated_at": "2025-09-12T06:15:00Z",
      "description": "Create MCP tool that provides instant project awareness by showing file structure with extracted documentation and purpose for each file",
      "requirements": [
        "Scan project directory recursively from configured project root",
        "Extract Python module docstrings, class docstrings, and main function docs",
        "Extract JavaScript/TypeScript file-level comments, JSDoc, and export descriptions",
        "Parse README files for project overview",
        "Extract package.json descriptions for Node projects",
        "Generate tree structure with inline descriptions like 'main.py - MCP server with ticket tools'",
        "Support .napkinignore file for custom exclusions",
        "Include file stats (size, last modified) as optional parameter",
        "Identify hot files (recently modified) with optional highlighting",
        "Cache results with smart invalidation on file changes"
      ],
      "acceptance_criteria": [
        "Tool returns complete file tree with descriptions in under 3 seconds",
        "Successfully extracts module/class/function docstrings from Python files",
        "Extracts top-level comments and JSDoc from JavaScript/TypeScript files",
        "Handles missing docstrings gracefully with fallback descriptions",
        "Ignores common non-code directories (venv, node_modules, __pycache__, .git)",
        "Output is clean and hierarchical for easy AI parsing",
        "Supports filtering by file type or directory",
        "Handles large projects without memory issues"
      ],
      "files_affected": [
        "main.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-005",
      "title": "Implement PyWebView for seamless diagram editor integration",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T05:35:04Z",
      "updated_at": "2025-09-12T06:45:00Z",
      "description": "Replace temp file approach with PyWebView for seamless diagram input flow - spawn native window, draw, send directly to Claude without copy-paste",
      "requirements": [
        "Add PyWebView dependency to pyproject.toml",
        "Create spawn_diagram_editor MCP tool that creates PyWebView window",
        "Expose Python callback function to JavaScript bridge for receiving ASCII data",
        "Modify diagram.html to detect window.pywebview availability",
        "Change 'Generate' button logic to call window.pywebview.api.send_diagram(data) when in PyWebView mode",
        "Keep existing clipboard mode for regular web access",
        "Remove file:// protocol temp file saving logic",
        "Window size 1200x800 with title 'NapkinWire Diagram'",
        "Tool waits for window close and returns received ASCII or error message",
        "Add 30 second timeout with graceful handling"
      ],
      "acceptance_criteria": [
        "Diagram editor opens in native PyWebView window on tool call",
        "ASCII diagram data passes directly from JS to Python via bridge",
        "Window closes automatically after send",
        "No temp files created or needed",
        "Works on Windows and Linux",
        "Existing web/clipboard modes remain functional",
        "Clean error handling if window closed without sending",
        "Tool returns ASCII diagram with full annotations to Claude"
      ],
      "files_affected": [
        "main.py",
        "web/diagram.html",
        "web/diagram-gen.js",
        "pyproject.toml"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-006",
      "title": "Create roadmap append and list tools for idea capture",
      "status": "done",
      "priority": "medium",
      "created_at": "2025-09-12T05:44:28Z",
      "updated_at": "2025-09-12T12:13:20Z",
      "description": "Create simple roadmap tools for capturing ideas quickly without formal ticket overhead - just append ideas and view them",
      "requirements": [
        "Create append_roadmap_idea tool accepting title, description, and optional category",
        "Categories: now, next, soon, later, ideas (default: ideas)",
        "Append format: '## [Category] Title\\n*Added: timestamp*\\nDescription\\n---'",
        "Create list_roadmap_ideas tool with optional category filter",
        "Return formatted string suitable for display",
        "Create roadmap.md if doesn't exist with header",
        "Use file locking to prevent corruption",
        "Ideas should append to end of their category section",
        "Include idea count in list output"
      ],
      "acceptance_criteria": [
        "Both tools work without errors",
        "Ideas persist to roadmap.md file",
        "Append tool adds with timestamp and proper formatting",
        "List tool returns readable formatted output",
        "File created automatically if doesn't exist",
        "Handles concurrent appends gracefully",
        "No duplicate ideas added if called twice rapidly",
        "Clean markdown formatting maintained"
      ],
      "files_affected": [
        "main.py",
        "roadmap.md"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-007",
      "title": "Implement roadmap tools to capture these ideas properly",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T11:44:32Z",
      "updated_at": "2025-09-12T16:45:00Z",
      "description": "Create simple roadmap tools for capturing ideas quickly - append and list functionality for brain dumps without ticket ceremony",
      "requirements": [
        "Create append_roadmap_idea tool with title, description, category parameters",
        "Create list_roadmap_ideas tool with optional category filter",
        "Auto-create roadmap.md with your existing notes as initial content",
        "Categories: now, next, soon, later, ideas",
        "Include timestamp when ideas are added",
        "Preserve your existing 'Random notes' section"
      ],
      "acceptance_criteria": [
        "Tools successfully append ideas to roadmap.md",
        "List tool displays all roadmap items clearly",
        "Markdown formatting is clean and readable",
        "Categories are properly organized",
        "No data loss on concurrent writes"
      ],
      "files_affected": [
        "main.py",
        "roadmap.md"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-008",
      "title": "Fix PyWebView threading with subprocess approach",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T12:09:04Z",
      "updated_at": "2025-09-12T12:13:20Z",
      "description": "Fix PyWebView main thread issue by running diagram editor in subprocess with its own main thread, using temp file for communication",
      "requirements": [
        "Modify spawn_diagram_editor tool to use subprocess.run with Python code string",
        "Create temp file for result passing between subprocess and main process",
        "Subprocess code creates PyWebView window with diagram.html",
        "Expose Python callback function to JavaScript for data transfer",
        "JavaScript detects pywebview.api availability and calls send function",
        "Write result to temp file before window closes",
        "Main process reads temp file and returns content",
        "Clean up temp file after reading",
        "Add error handling for subprocess failures",
        "Include logging for debugging without stdout pollution"
      ],
      "acceptance_criteria": [
        "Diagram editor successfully opens in subprocess window",
        "ASCII data passes from JavaScript to Python correctly",
        "Window closes after sending data",
        "Tool returns ASCII diagram to Claude",
        "No main thread errors",
        "Handles window close without sending gracefully",
        "Works on Windows and Linux",
        "Timeout after 60 seconds if no response"
      ],
      "files_affected": [
        "main.py",
        "web/diagram.html",
        "web/diagram-gen.js"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-009",
      "title": "Create Claude Code queue daemon for automatic ticket execution",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-12T12:18:28Z",
      "updated_at": "2025-09-12T12:18:28Z",
      "description": "Create a file-based queue system with daemon that watches for tickets and automatically launches Claude Code to implement them",
      "requirements": [
        "Create claude_code_daemon.py script that polls ticket_queue directory",
        "Add queue_ticket_for_claude_code MCP tool that writes ticket files",
        "Queue directory: ./ticket_queue/ (create if not exists)",
        "File format: TICKET-XXX.queue containing ticket details",
        "Daemon polls every 5 seconds for new .queue files",
        "Launch Claude Code with: subprocess.run(['claude', 'code', f'Implement {ticket_id} from tickets.json'])",
        "Move processed files to ./ticket_queue/processed/ with timestamp",
        "Add daemon status check tool to see if it's running",
        "Include start instructions in docstring or README",
        "Daemon should be stoppable with Ctrl+C gracefully"
      ],
      "acceptance_criteria": [
        "Daemon successfully watches queue directory for new tickets",
        "Claude Code launches when ticket file appears",
        "Non-blocking operation - daemon continues running",
        "Ticket files removed after processing",
        "Graceful error handling if Claude Code fails",
        "Daemon can be started/stopped manually",
        "Logs activity to file for debugging",
        "Works with relative paths within git repository"
      ],
      "files_affected": [
        "claude_code_daemon.py",
        "main.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-010",
      "title": "Initiative Feed: Database setup and basic operations",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-12T16:18:21Z",
      "updated_at": "2025-09-12T16:18:21Z",
      "description": "Set up SQLite database for Initiative Feed with category tables and basic read/write operations",
      "requirements": [
        "Create SQLite database file: initiative_feed.db",
        "Schema: id, timestamp, category, priority, message, context fields",
        "Create three tables for different categories",
        "Write function to add feed entry",
        "Write function to read entries by category",
        "Create MCP tool: read_initiative_feed(category=None, limit=10)",
        "Return formatted dict with entries"
      ],
      "acceptance_criteria": [
        "SQLite database created with proper schema",
        "Tables for: codebase_insights, workflow_patterns, quality_metrics",
        "CRUD functions work without errors",
        "MCP tool returns feed entries in readable format",
        "Database file stored in project directory",
        "Handles empty database gracefully",
        "Timestamp and priority fields functioning"
      ],
      "files_affected": [
        "main.py",
        "initiative_feed.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-011",
      "title": "Initiative Feed: Git change detector",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-12T16:18:32Z",
      "updated_at": "2025-09-12T16:18:32Z",
      "description": "Create git change detector that parses diffs and extracts what changed in commits",
      "requirements": [
        "Create function to run git diff HEAD~1",
        "Parse output to extract changed files list",
        "Get commit message with git log -1",
        "Get commit hash and author",
        "Format as feed entry with context",
        "Store in database using ticket 1's functions",
        "Handle case when not in git repository",
        "Return summary of what was captured"
      ],
      "acceptance_criteria": [
        "Successfully parses git diff output",
        "Extracts list of changed files",
        "Captures commit message and hash",
        "Stores data in feed database",
        "Handles different git operations (add, modify, delete)",
        "Works with relative file paths",
        "Processes multi-file commits correctly"
      ],
      "files_affected": [
        "initiative_feed.py",
        "git_monitor.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-012",
      "title": "Initiative Feed: Git hook installer",
      "status": "todo",
      "priority": "medium",
      "created_at": "2025-09-12T16:18:41Z",
      "updated_at": "2025-09-12T16:18:41Z",
      "description": "Install git post-commit hook that automatically triggers feed updates after commits",
      "requirements": [
        "Create install_hook.py script",
        "Generate post-commit hook file content",
        "Hook calls python script with git info",
        "Check if hook already exists",
        "Backup existing hooks if present",
        "Make hook executable on Linux",
        "Add uninstall function",
        "Include instructions for manual setup",
        "Test with actual git commit"
      ],
      "acceptance_criteria": [
        "Git hook successfully installs in .git/hooks/",
        "Hook triggers after each commit",
        "Executes git change detector from ticket 11",
        "Writes results to feed database",
        "Non-blocking operation",
        "Works on Windows and Linux",
        "Can be uninstalled cleanly",
        "Doesn't interfere with existing hooks"
      ],
      "files_affected": [
        "install_hook.py",
        ".git/hooks/post-commit"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-013",
      "title": "Initiative Feed: Summary presenter tool",
      "status": "todo",
      "priority": "medium",
      "created_at": "2025-09-12T16:18:51Z",
      "updated_at": "2025-09-12T16:18:51Z",
      "description": "Create MCP tool that queries feed database and presents organized summary of insights",
      "requirements": [
        "Create check_initiative_feed MCP tool",
        "Query last N entries from each category",
        "Sort by priority then timestamp",
        "Format as readable sections",
        "Include entry counts per category",
        "Auto-cleanup entries older than 30 days",
        "Support filtering by date range",
        "Return structured dict for Claude to interpret"
      ],
      "acceptance_criteria": [
        "Tool queries database and returns formatted summary",
        "Groups entries by category correctly",
        "Respects limit parameter",
        "Formats output for easy reading",
        "Handles empty database gracefully",
        "Shows most recent entries first",
        "Cleans old entries (30+ days) automatically",
        "Returns counts per category"
      ],
      "files_affected": [
        "main.py",
        "initiative_feed.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-014",
      "title": "Initiative Feed: Code comment extractor",
      "status": "todo",
      "priority": "medium",
      "created_at": "2025-09-12T16:19:02Z",
      "updated_at": "2025-09-12T16:19:02Z",
      "description": "Scan codebase for docstrings and comments to extract purpose and context information",
      "requirements": [
        "Create scan_code_comments function",
        "Use regex to find Python docstrings",
        "Extract top-of-file comments from JS/TS",
        "Find all TODO/FIXME/NOTE comments",
        "Parse out the 'why' from docstrings",
        "Store each finding as feed entry",
        "Category: 'codebase_insights'",
        "Include file path in context",
        "Run on demand, not automatic"
      ],
      "acceptance_criteria": [
        "Successfully extracts Python docstrings",
        "Extracts JavaScript/TypeScript top comments",
        "Finds TODO and FIXME comments",
        "Stores findings in feed database",
        "Handles files without comments gracefully",
        "Processes multiple files efficiently",
        "Groups findings by file",
        "Works with project tree structure"
      ],
      "files_affected": [
        "code_scanner.py",
        "initiative_feed.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-015",
      "title": "Fix usage analyzer time calculation and window detection bugs",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-12T16:22:30Z",
      "updated_at": "2025-09-12T16:39:43Z",
      "description": "Fix usage analyzer's broken time calculations and window detection logic - currently showing 11 hours elapsed when only 22 minutes have passed",
      "requirements": [
        "Debug timezone conversion between log timestamps and local time",
        "Fix window boundary detection (5 hours usage, 5 hours cooldown)",
        "Ensure message count only includes current window",
        "Verify time elapsed matches actual time since window started",
        "Add logging to show calculation steps for debugging",
        "Test with various scenarios: fresh window, mid-window, expired",
        "Handle case where logs span multiple days",
        "Ensure burn rate calculation uses correct time period",
        "Add sanity checks (elapsed time cannot exceed 5 hours in active window)"
      ],
      "acceptance_criteria": [
        "Correctly identifies current 5-hour window start time",
        "Accurate time elapsed calculation",
        "Proper timezone handling (local vs UTC)",
        "Only counts messages from current window, not cumulative",
        "Detects window resets accurately",
        "Time remaining calculation matches actual limit",
        "Handles edge cases like window just started or just expired",
        "Math calculations are verifiable and correct"
      ],
      "files_affected": [
        "mcp/usage_analysis.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-016",
      "title": "Fix diagram editor subprocess timeout issue",
      "status": "obsolete",
      "priority": "high",
      "created_at": "2025-09-12T16:28:02Z",
      "updated_at": "2025-09-13T22:06:47Z",
      "description": "Fix diagram editor timeout issue - tool works in testing but times out after 60 seconds when called from Claude Desktop",
      "requirements": [
        "Debug why subprocess isn't launching properly from MCP context",
        "Check if PATH or environment variables are different in MCP",
        "Verify python executable path is correct",
        "Test if subprocess needs shell=True on Windows",
        "Add debug logging to see where it's failing",
        "Consider removing timeout or making it configurable",
        "Test alternative launch methods if subprocess fails",
        "Ensure window actually appears on screen",
        "Handle case where pywebview needs different initialization in subprocess"
      ],
      "acceptance_criteria": [
        "Diagram editor opens successfully when called from Claude",
        "No timeout errors",
        "Window appears and is interactive",
        "Subprocess launches correctly",
        "Works from both Claude Desktop and testing environments",
        "Error messages are informative if it fails",
        "Handles both quick and slow responses gracefully"
      ],
      "files_affected": [
        "main.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-017",
      "title": "Create Python ticket formatter/summary script",
      "status": "done",
      "priority": "medium",
      "created_at": "2025-09-12T16:37:50Z",
      "updated_at": "2025-09-12T16:52:00Z",
      "description": "Create a simple Python script that reads tickets.json and outputs a formatted summary without needing LLM calls",
      "requirements": [
        "Read tickets.json file",
        "Parse and group tickets by status (todo/in_progress/done/blocked)",
        "Within each status, sort by priority (high/medium/low)",
        "Generate text output with sections for each status",
        "Show ticket ID, title, and priority for each",
        "Add summary counts at the top",
        "Highlight any blocked tickets or dependencies",
        "Optional: add ASCII art dividers for readability",
        "Optional: colorized output for terminal",
        "Make it executable from command line"
      ],
      "acceptance_criteria": [
        "Script runs standalone without dependencies",
        "Outputs clear text summary of tickets",
        "Groups tickets by status and priority",
        "Shows counts for each category",
        "Highlights critical/blocked tickets",
        "Runs in under 1 second",
        "Works with current tickets.json format",
        "Output is easy to read at a glance"
      ],
      "files_affected": [
        "ticket_summary.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-018",
      "title": "Research Podman containerization for MCP on Windows",
      "status": "todo",
      "priority": "medium",
      "created_at": "2025-09-13T03:40:10Z",
      "updated_at": "2025-09-13T03:40:10Z",
      "description": "Research Podman containerization for NapkinWire MCP server on Windows, create report covering feasibility, setup, volume handling, and configuration approaches",
      "requirements": [
        "Research Podman installation on Windows (WSL2 vs native)",
        "Document how to handle volume mounts for tickets.json and project files",
        "Investigate passing config via arguments vs environment variables",
        "Compare resource usage vs native Python",
        "Document Dockerfile structure for MCP server",
        "Research stdio communication through container",
        "Identify potential issues with GUI tools (PyWebView)",
        "Create example Podman commands for testing",
        "List pros and cons vs current approach",
        "Provide recommendation on whether to proceed"
      ],
      "acceptance_criteria": [
        "Research document created as markdown file",
        "Covers all key aspects of Podman on Windows for MCP",
        "Provides clear recommendations",
        "Includes practical examples",
        "Addresses volume mounting and path issues",
        "No implementation required, just research"
      ],
      "files_affected": [
        "podman_research.md"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-019",
      "title": "Implement local HTTP server for diagram editor instead of PyWebView",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-13T03:44:12Z",
      "updated_at": "2025-09-13T07:34:50Z",
      "description": "Replace PyWebView with local HTTP server approach - start server, open browser to web/diagram.html, capture POST request with ASCII data, return to Claude",
      "requirements": [
        "Modify spawn_diagram_editor tool to start HTTP server on localhost",
        "Find available port (try 8765, increment if busy)",
        "Serve web/ directory as static files",
        "Add POST endpoint /send_to_claude to receive ASCII data",
        "Modify diagram.html to detect localhost mode",
        "Change generate button to POST to /send_to_claude when on localhost",
        "Open browser automatically to http://localhost:PORT/diagram.html",
        "Server waits for POST request with 60 second timeout",
        "Return received ASCII data and shut down server",
        "Handle CORS if needed for localhost"
      ],
      "acceptance_criteria": [
        "Local HTTP server starts on available port",
        "Browser opens automatically with diagram.html",
        "Server receives POST request with ASCII data",
        "Tool returns ASCII data to Claude",
        "Server shuts down after receiving data",
        "No timeout errors",
        "Works on Windows and Linux",
        "Handles user closing browser without sending"
      ],
      "files_affected": [
        "main.py",
        "web/diagram.html",
        "web/diagram-gen.js"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-020",
      "title": "Create MCP test client for local tool testing",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T03:46:59Z",
      "updated_at": "2025-09-13T03:46:59Z",
      "description": "Create a simple MCP test client that simulates Claude's tool calls for testing without burning API tokens",
      "requirements": [
        "Create standalone test_client.py script",
        "Start MCP server using subprocess with same args as Claude config",
        "Establish stdio communication with server",
        "Send proper JSON-RPC messages for tool calls",
        "Interactive mode: prompt for tool name and parameters",
        "Display tool response formatted nicely",
        "List available tools command",
        "Handle connection errors and timeouts",
        "Example usage in comments or docstring"
      ],
      "acceptance_criteria": [
        "Test client starts MCP server same way Claude does",
        "Can call any tool by name with parameters",
        "Shows tool response clearly",
        "Handles errors gracefully",
        "Simple command-line interface",
        "No token costs for testing"
      ],
      "files_affected": [
        "test_client.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-021",
      "title": "Implement HTTP server for UI mockup editor matching diagram approach",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-13T07:39:18Z",
      "updated_at": "2025-09-13T13:13:39Z",
      "description": "Implement local HTTP server for UI mockup editor using same approach as diagram tool (TICKET-019) - start server, open browser to web/ui.html, capture POST request with ASCII mockup data, return to Claude",
      "requirements": [
        "Copy implementation pattern from spawn_diagram_editor",
        "Create spawn_ui_mockup_editor tool",
        "Start HTTP server on localhost (find available port)",
        "Serve web/ directory as static files",
        "Add POST endpoint /send_to_claude for UI mockup data",
        "Modify ui.html to detect localhost mode",
        "Change generate button to POST to /send_to_claude when on localhost",
        "Open browser to http://localhost:PORT/ui.html",
        "Server waits for POST with 60 second timeout",
        "Return received ASCII UI mockup and shut down server",
        "Use same CORS handling as diagram tool"
      ],
      "acceptance_criteria": [
        "Local HTTP server starts for UI mockup tool",
        "Browser opens automatically with ui.html",
        "Server receives POST request with ASCII UI data",
        "Tool returns ASCII mockup to Claude",
        "Server shuts down cleanly after receiving data",
        "No timeout errors",
        "Works on Windows and Linux",
        "Handles user closing browser without sending"
      ],
      "files_affected": [
        "main.py",
        "web/ui.html",
        "web/main.js"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-022",
      "title": "Setup Aider with free OpenRouter models for automated implementation",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-13T12:29:11Z",
      "updated_at": "2025-09-13T12:45:12Z",
      "description": "Configure Aider to use free tier models from OpenRouter (like Qwen2.5-Coder, DeepSeek, or others marked as free) for automated ticket implementation. This will preserve Claude usage for high-level design while delegating routine coding to free models.",
      "requirements": [
        "Research current free models on OpenRouter",
        "Install Aider if not present",
        "Create .aider.conf.yml with OpenRouter configuration",
        "Test with a simple ticket implementation",
        "Document usage patterns and cost tracking"
      ],
      "acceptance_criteria": [
        "Aider successfully connects to OpenRouter",
        "Can execute a simple code change using free model",
        "Process documented for ticket-to-Aider workflow",
        "No Claude tokens used for routine implementation"
      ],
      "files_affected": [
        ".aider.conf.yml",
        "mcp/main.py",
        "docs/aider-setup.md"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-023",
      "title": "Refactor main.py into modules (NO Claude implementation)",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-13T12:29:22Z",
      "updated_at": "2025-09-13T13:13:39Z",
      "description": "Refactor the 46KB main.py into logical modules WITHOUT using Claude for implementation. Use Aider+free models or manual refactoring. Core modules: ticket_manager.py, roadmap_manager.py, usage_analyzer.py, project_tools.py, diagram_server.py. Main.py should only handle MCP server setup and tool registration.",
      "requirements": [
        "Extract ticket-related functions to ticket_manager.py",
        "Extract roadmap functions to roadmap_manager.py",
        "Extract project tree functions to project_tools.py",
        "Extract diagram server to diagram_server.py",
        "Keep usage_analyzer.py as is",
        "Update imports in main.py"
      ],
      "acceptance_criteria": [
        "main.py reduced to under 10KB",
        "Each module has single responsibility",
        "All existing functionality preserved",
        "Import structure clean and logical"
      ],
      "files_affected": [
        "mcp/main.py",
        "mcp/ticket_manager.py",
        "mcp/roadmap_manager.py",
        "mcp/project_tools.py",
        "mcp/diagram_server.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-024",
      "title": "Setup pytest infrastructure with test templates for Aider",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T12:29:31Z",
      "updated_at": "2025-09-13T12:29:31Z",
      "description": "Set up testing infrastructure using pytest. Create test structure and basic tests for critical functions. Use Aider+free models to write the actual tests. Focus on: ticket CRUD operations, roadmap operations, file reading, and critical MCP tool functions.",
      "requirements": [
        "Install pytest and pytest-cov",
        "Create tests/ directory structure",
        "Write fixture for test data",
        "Create test templates that Aider can fill",
        "Set up GitHub Actions workflow (optional)"
      ],
      "acceptance_criteria": [
        "Pytest configured and running",
        "Basic test structure created",
        "CI/CD ready test command",
        "Coverage report generated"
      ],
      "files_affected": [
        "tests/test_tickets.py",
        "tests/test_roadmap.py",
        "tests/test_mcp_tools.py",
        "pytest.ini",
        ".github/workflows/tests.yml"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-025",
      "title": "Implementation Guide: Aider Setup with OpenRouter",
      "status": "done",
      "priority": "high",
      "created_at": "2025-09-13T12:31:27Z",
      "updated_at": "2025-09-13T13:13:39Z",
      "description": "SPECIFIC STEPS for TICKET-022 that Sonnet can execute directly:\n\n1. INSTALL AIDER:\n```bash\npip install aider-chat\n```\n\n2. CREATE .aider.conf.yml in project root:\n```yaml\nopenrouter:\n  api_key: ${OPENROUTER_API_KEY}\n  model: openrouter/qwen/qwen-2.5-coder-32b-instruct\n  # Alternative free models to try:\n  # - openrouter/microsoft/phi-3-mini-128k-instruct:free\n  # - openrouter/google/gemma-2-9b-it:free\n  # - openrouter/meta-llama/llama-3.2-3b-instruct:free\n\n# Aider settings\nauto_commits: true\ndirty_commits: false\ngit: true\nvoice: false\n```\n\n3. CREATE mcp/tools/aider_integration.py:\n```python\nimport subprocess\nimport os\nfrom pathlib import Path\n\ndef run_aider_on_ticket(ticket_id, ticket_description, requirements):\n    '''Execute Aider with ticket requirements as prompt'''\n    prompt = f'Implement {ticket_id}: {ticket_description}\\\\n\\\\nRequirements:\\\\n' + '\\\\n'.join(requirements)\n    \n    cmd = ['aider', '--message', prompt, '--yes']\n    \n    result = subprocess.run(cmd, capture_output=True, text=True)\n    return result.stdout, result.returncode\n```\n\n4. TEST with simple task:\n```bash\nexport OPENROUTER_API_KEY='your-key-here'\naider --message 'Add a docstring to the add function in main.py'\n```\n\n5. CREATE docs/aider-setup.md documenting the process",
      "requirements": [
        "Copy-paste executable code",
        "No design decisions needed",
        "Test each step independently"
      ],
      "acceptance_criteria": [
        "Aider runs successfully with OpenRouter",
        "Can make a simple code change",
        "Documentation created"
      ],
      "files_affected": [
        ".aider.conf.yml",
        "mcp/tools/aider_integration.py",
        "docs/aider-setup.md"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-026",
      "title": "Implementation Guide: Refactor main.py (mechanical steps)",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T12:31:43Z",
      "updated_at": "2025-09-13T12:31:43Z",
      "description": "MECHANICAL REFACTORING STEPS for TICKET-023 (no design decisions):\n\n1. CREATE mcp/modules/ticket_manager.py and MOVE these functions from main.py:\n- load_tickets()\n- save_tickets()\n- create_ticket()\n- napkinwire_create_ticket()\n- napkinwire_list_tickets()\n- napkinwire_update_ticket_status()\n- napkinwire_get_ticket_details()\n\n2. CREATE mcp/modules/roadmap_manager.py and MOVE:\n- napkinwire_append_roadmap_idea()\n- napkinwire_list_roadmap_ideas()\n\n3. CREATE mcp/modules/project_tools.py and MOVE:\n- napkinwire_project_tree()\n- Any helper functions for project tree\n\n4. CREATE mcp/modules/diagram_server.py and MOVE:\n- napkinwire_spawn_diagram_editor()\n- DiagramHandler class\n- All diagram-related helper functions\n\n5. UPDATE main.py imports:\n```python\nfrom modules.ticket_manager import (\n    napkinwire_create_ticket,\n    napkinwire_list_tickets,\n    napkinwire_update_ticket_status,\n    napkinwire_get_ticket_details\n)\nfrom modules.roadmap_manager import (\n    napkinwire_append_roadmap_idea,\n    napkinwire_list_roadmap_ideas\n)\nfrom modules.project_tools import napkinwire_project_tree\nfrom modules.diagram_server import napkinwire_spawn_diagram_editor\n```\n\n6. KEEP in main.py:\n- MCP server initialization\n- Tool registration (@server.tool decorators)\n- Main entry point\n- Basic imports\n\n7. TEST each tool still works after refactoring",
      "requirements": [
        "Pure cut-and-paste operation",
        "No logic changes",
        "Preserve all decorators and function signatures"
      ],
      "acceptance_criteria": [
        "All functions moved to appropriate modules",
        "main.py only contains MCP server code",
        "All tools still work"
      ],
      "files_affected": [
        "mcp/main.py",
        "mcp/modules/ticket_manager.py",
        "mcp/modules/roadmap_manager.py",
        "mcp/modules/project_tools.py",
        "mcp/modules/diagram_server.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-027",
      "title": "Implementation Guide: pytest setup with working examples",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T12:32:00Z",
      "updated_at": "2025-09-13T12:32:00Z",
      "description": "STEP-BY-STEP TEST SETUP for TICKET-024:\n\n1. INSTALL testing dependencies:\n```bash\npip install pytest pytest-cov pytest-mock\n```\n\n2. CREATE pytest.ini in project root:\n```ini\n[pytest]\ntestpaths = tests\npython_files = test_*.py\npython_classes = Test*\npython_functions = test_*\naddopts = -v --cov=mcp --cov-report=html --cov-report=term\n```\n\n3. CREATE tests/__init__.py (empty file)\n\n4. CREATE tests/conftest.py with fixtures:\n```python\nimport pytest\nimport json\nfrom pathlib import Path\n\n@pytest.fixture\ndef temp_tickets_file(tmp_path):\n    '''Create temporary tickets.json for testing'''\n    tickets_file = tmp_path / 'tickets.json'\n    tickets_file.write_text('[]')\n    return tickets_file\n\n@pytest.fixture\ndef sample_ticket():\n    return {\n        'id': 'TEST-001',\n        'title': 'Test ticket',\n        'status': 'todo',\n        'priority': 'high',\n        'description': 'Test description',\n        'requirements': ['req1', 'req2'],\n        'acceptance_criteria': ['ac1', 'ac2'],\n        'files_affected': ['file1.py']\n    }\n```\n\n5. CREATE tests/test_tickets.py with basic test:\n```python\ndef test_ticket_creation(sample_ticket):\n    '''Test that a ticket has required fields'''\n    assert 'id' in sample_ticket\n    assert 'title' in sample_ticket\n    assert sample_ticket['status'] in ['todo', 'in_progress', 'done']\n```\n\n6. RUN tests to verify setup:\n```bash\npytest\n```\n\n7. CREATE tests/test_roadmap.py (placeholder):\n```python\ndef test_roadmap_placeholder():\n    '''Placeholder test for roadmap functionality'''\n    assert True  # Replace with actual tests\n```\n\n8. CREATE .github/workflows/tests.yml (optional):\n```yaml\nname: Tests\non: [push, pull_request]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - uses: actions/setup-python@v2\n      with:\n        python-version: '3.11'\n    - run: pip install -e . pytest pytest-cov\n    - run: pytest\n```",
      "requirements": [
        "All code is copy-pasteable",
        "Each file is complete and runnable",
        "No design decisions needed"
      ],
      "acceptance_criteria": [
        "pytest runs successfully",
        "At least one test passes",
        "Test structure ready for expansion"
      ],
      "files_affected": [
        "pytest.ini",
        "tests/__init__.py",
        "tests/conftest.py",
        "tests/test_tickets.py",
        "tests/test_roadmap.py",
        ".github/workflows/tests.yml"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-028",
      "title": "Create context restore tool for new chat sessions",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T13:00:29Z",
      "updated_at": "2025-09-13T13:04:23Z",
      "description": "Create an MCP tool that extracts and returns essential project context for new chat sessions. When called, it should gather:\n\n1. Current project status summary\n2. Active high-priority tickets (todo items)\n3. Recently completed work (last 3-5 done tickets)\n4. Current roadmap focus areas (Next/Soon items)\n5. Any critical project constants/decisions from CLAUDE.md or README.md\n6. Current working directory and active files\n\nThe tool should return a concise, formatted summary that can be passed to a new Claude session to instantly restore context. No ChromaDB needed yet - just read from existing files (tickets.json, roadmap.md, recent git commits, etc.).\n\nExample output:\n```\nPROJECT CONTEXT RESTORE\n=======================\nProject: NapkinWire MCP Tools\nStatus: 10 completed, 11 todo tickets\n\nCURRENT FOCUS:\n- Setting up Aider integration with free models\n- Refactoring main.py into modules\n- Building Initiative Engine foundation\n\nRECENT COMPLETIONS:\n- TICKET-019: HTTP server for diagram editor\n- TICKET-015: Fixed usage analyzer\n- TICKET-007: Roadmap tools implemented\n\nACTIVE HIGH-PRIORITY:\n- TICKET-009: Claude Code queue daemon\n- TICKET-022: Aider setup with OpenRouter\n- TICKET-023: Refactor main.py\n\nKEY DECISIONS:\n- Using HTTP server instead of PyWebView\n- Prioritizing free model integration\n- Initiative Engine for push-based LLM actions\n```\n\nThis becomes the 'context pill' you give to each new chat.",
      "requirements": [
        "Read tickets.json for active/recent tickets",
        "Parse roadmap.md for current focus",
        "Extract key info from CLAUDE.md/README.md",
        "Format as concise summary",
        "Add as @server.tool to main.py"
      ],
      "acceptance_criteria": [
        "Tool successfully extracts key project facts",
        "Returns formatted context summary",
        "Can be called at start of new chat",
        "Includes active tickets, recent decisions, and current focus"
      ],
      "files_affected": [
        "mcp/main.py",
        "mcp/modules/context_manager.py",
        "tickets.json",
        "roadmap.md"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-029",
      "title": "Create decision/context saving tool for persistent memory",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T13:01:53Z",
      "updated_at": "2025-09-13T13:01:53Z",
      "description": "Create an MCP tool to save important decisions and context during chat sessions. This captures the \"why\" behind choices that need to persist across sessions.\n\nTool signature:\n```python\n@server.tool()\nasync def napkinwire_save_decision(\n    decision: str,\n    category: str = \"general\",  # architecture, tooling, process, design, general\n    context: str = None  # Optional additional context\n) -> str:\n    '''Save a key project decision or context for future sessions'''\n```\n\nSaves to a structured file (decisions.json or decisions.md) with:\n- Timestamp\n- Category\n- Decision text\n- Optional context/rationale\n- Chat session ID (if available)\n\nExample usage:\n- napkinwire_save_decision(\"Use Aider + free OpenRouter models for all routine coding\", \"tooling\", \"Preserves Claude tokens for design work\")\n- napkinwire_save_decision(\"Refactor main.py into modules for maintainability\", \"architecture\")\n- napkinwire_save_decision(\"Initiative Engine needs both push and pull mechanisms\", \"design\", \"MCP is pull-only, need orchestration layer\")\n\nStorage format (decisions.json):\n```json\n{\n  \"decisions\": [\n    {\n      \"id\": \"DEC-001\",\n      \"timestamp\": \"2025-09-13T12:45:00Z\",\n      \"category\": \"tooling\",\n      \"decision\": \"Use Aider + free OpenRouter models for all routine coding\",\n      \"context\": \"Preserves Claude tokens for design work\",\n      \"session\": \"chat-abc123\"\n    }\n  ]\n}\n```\n\nThe context_restore tool (TICKET-028) should read from this file and include recent/important decisions in its output.\n\nBonus: Add a napkinwire_list_decisions(category=None, recent=5) tool to query past decisions.",
      "requirements": [
        "Create decisions.json structure",
        "Implement save_decision tool",
        "Add auto-incrementing ID system",
        "Include timestamp for each decision",
        "Update context_restore to read decisions",
        "Optional: Add list_decisions tool for querying"
      ],
      "acceptance_criteria": [
        "Tool saves key decisions/choices to persistent file",
        "Decisions are timestamped and categorized",
        "Can be retrieved by context_restore tool",
        "Supports different decision types (architecture, process, tooling)"
      ],
      "files_affected": [
        "mcp/main.py",
        "mcp/modules/context_manager.py",
        "decisions.json"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-030",
      "title": "UPDATE TICKET-028: Add max_tokens parameter for context control",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T13:04:49Z",
      "updated_at": "2025-09-13T13:04:49Z",
      "description": "UPDATE for TICKET-028: Add max_tokens parameter and layered context approach.\n\nTool signature should be:\n```python\n@server.tool()\nasync def napkinwire_context_restore(max_tokens: int = 1000) -> str:\n    '''Restore essential project context with token budget\n    \n    Args:\n        max_tokens: Maximum tokens for context (default 1000)\n            - 500: Bare minimum (current task + active tickets)\n            - 1000: Standard (+ recent decisions + completions)\n            - 2000: Detailed (+ roadmap + project stats)\n            - 5000: Full (+ file tree + git status)\n    '''\n```\n\nImplementation with layered context:\n```python\ndef build_context_summary(max_tokens=1000):\n    summary = \"\"\n    token_count = 0\n    \n    # LAYER 1: Critical (always include, ~200 tokens)\n    critical = f\"\"\"\n=== NAPKINWIRE CONTEXT ===\n CURRENT: {get_active_goal()}\n ACTIVE: {get_active_tickets(max=3)}\n\"\"\"\n    summary += critical\n    token_count += estimate_tokens(critical)\n    \n    # LAYER 2: Helpful (if budget allows, ~300 tokens)\n    if token_count < max_tokens - 300:\n        helpful = f\"\"\"\n DECISIONS: {get_recent_decisions(max=3)}\n COMPLETED: {get_recent_done(max=3)}\n\"\"\"\n        summary += helpful\n        token_count += estimate_tokens(helpful)\n    \n    # LAYER 3: Detailed (if budget allows, ~500 tokens)\n    if token_count < max_tokens - 500:\n        detailed = f\"\"\"\n STATS: {done_count} done, {todo_count} todo\n ROADMAP: {get_roadmap_next(max=3)}\n\"\"\"\n        summary += detailed\n        token_count += estimate_tokens(detailed)\n    \n    # LAYER 4: Full context (if budget allows)\n    if token_count < max_tokens - 1000:\n        full = f\"\"\"\n PROJECT TREE: {get_project_structure()}\n GIT STATUS: {get_git_status()}\n\"\"\"\n        summary += full\n    \n    return summary\n\ndef estimate_tokens(text: str) -> int:\n    # Rough estimate: 1 token  4 characters\n    return len(text) // 4\n```\n\nUsage examples:\n- `napkinwire_context_restore(500)` - Minimal context for quick questions\n- `napkinwire_context_restore(1000)` - Standard restore (default)\n- `napkinwire_context_restore(5000)` - Full context for complex work\n\nThis update makes TICKET-028 much more flexible and efficient with context window usage.",
      "requirements": [
        "Add max_tokens parameter with default 1000",
        "Implement token estimation function",
        "Create layered context building",
        "Test with different token budgets",
        "Ensure graceful degradation if content exceeds budget"
      ],
      "acceptance_criteria": [
        "Tool accepts max_tokens parameter (default 1000)",
        "Returns layered context based on token budget",
        "Always includes critical context",
        "Progressively adds helpful and full context if budget allows",
        "Token counting is approximate but functional"
      ],
      "files_affected": [
        "mcp/main.py",
        "mcp/modules/context_manager.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-031",
      "title": "Create mission statement tool and integrate with context",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T13:07:01Z",
      "updated_at": "2025-09-13T13:07:01Z",
      "description": "Create a project mission statement tool and integrate it with context restore.\n\n1. CREATE mission.md file with project vision/mission:\n```markdown\n# NapkinWire Mission\n\n## Vision\n[Your vision statement here]\n\n## Mission\n[Core mission - what NapkinWire does and why]\n\n## Core Principles\n- [Principle 1]\n- [Principle 2]\n- [Principle 3]\n\n## Success Metrics\n- [How we measure success]\n\n## Non-Goals\n- [What we explicitly won't do]\n```\n\n2. CREATE MCP tool to read mission:\n```python\n@server.tool()\nasync def napkinwire_get_mission() -> str:\n    '''Get project mission statement and core principles'''\n    mission_file = Path('mission.md')\n    if mission_file.exists():\n        return mission_file.read_text()\n    return \"No mission statement found. Create mission.md\"\n```\n\n3. INTEGRATE with context_restore - mission should be in Layer 1 (critical context):\n```python\n# In context_restore tool\ncritical = f\"\"\"\n=== NAPKINWIRE CONTEXT ===\n MISSION: {get_mission_summary()}  # First line of mission\n CURRENT: {get_active_goal()}\n ACTIVE: {get_active_tickets(max=3)}\n\"\"\"\n```\n\nThis ensures every new chat starts with clear understanding of WHY the project exists and WHAT it's trying to achieve. All decisions should align with this mission.",
      "requirements": [
        "Create mission.md template",
        "Add get_mission tool",
        "Integrate with context_restore",
        "Mission should be concise but clear",
        "Include in critical context layer"
      ],
      "acceptance_criteria": [
        "Mission statement file exists and is readable",
        "Tool returns mission statement clearly",
        "Mission appears in context_restore output",
        "Mission guides project decisions"
      ],
      "files_affected": [
        "mission.md",
        "mcp/main.py",
        "mcp/modules/context_manager.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-032",
      "title": "Create Aider validation checklist and tests",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T13:07:24Z",
      "updated_at": "2025-09-13T13:07:24Z",
      "description": "Create Aider validation checklist to ensure quality before production use.\n\nVALIDATION CHECKLIST:\n```python\n# aider_validation.py\n\ndef validate_aider_setup():\n    '''Run all checks before using Aider in production'''\n    \n    checks = {\n        \"installation\": check_aider_installed(),\n        \"openrouter_auth\": check_api_key_valid(),\n        \"free_model_access\": test_free_model_call(),\n        \"git_integration\": test_git_commit(),\n        \"file_editing\": test_simple_edit(),\n        \"multi_file\": test_multi_file_edit(),\n        \"error_handling\": test_error_recovery(),\n        \"token_usage\": verify_zero_cost(),\n    }\n    \n    return all(checks.values()), checks\n\n# TEST 1: Simple edit\ndef test_simple_edit():\n    '''Test Aider can add a docstring'''\n    test_file = 'test_dummy.py'\n    create_test_file(test_file)\n    \n    result = run_aider(\n        \"Add a docstring to the greet function\",\n        files=[test_file]\n    )\n    \n    # Verify docstring was added\n    return '\"' in read_file(test_file)\n\n# TEST 2: Multi-file refactor\ndef test_multi_file_edit():\n    '''Test Aider can refactor across files'''\n    # Create function in file1, move to file2\n    pass\n\n# TEST 3: Error recovery\ndef test_error_recovery():\n    '''Test Aider handles syntax errors gracefully'''\n    pass\n\n# TEST 4: Cost verification\ndef verify_zero_cost():\n    '''Ensure we're using free models only'''\n    # Check OpenRouter dashboard or API\n    pass\n```\n\nRUN CHECKLIST:\n```bash\npython aider_validation.py\n\n Installation: PASS\n OpenRouter auth: PASS  \n Free model access: PASS\n Git integration: PASS\n File editing: PASS\n Multi-file editing: NEEDS REVIEW\n Error handling: PASS\n Zero cost verified: PASS\n\nDECISION: Ready for production with caution on multi-file edits\n```\n\nROLLBACK PLAN:\n1. If Aider corrupts code: `git reset --hard HEAD`\n2. If wrong model used: Check OpenRouter billing immediately\n3. If performance poor: Revert to manual coding for that ticket\n4. Keep manual override: --no-aider flag on all tools\n\nThis ensures Aider quality before we rely on it.",
      "requirements": [
        "Create validation script",
        "Test each critical feature",
        "Verify free model usage",
        "Create rollback procedures",
        "Document known limitations"
      ],
      "acceptance_criteria": [
        "All tests pass before Aider is used for real work",
        "Clear go/no-go decision",
        "Rollback plan if Aider causes issues",
        "Performance benchmarks established"
      ],
      "files_affected": [
        "aider_validation.py",
        "tests/test_aider_integration.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-033",
      "title": "Add cancelled/obsolete status to ticket system",
      "status": "done",
      "priority": "medium",
      "created_at": "2025-09-13T22:02:11Z",
      "updated_at": "2025-09-13T22:02:11Z",
      "description": "Current ticket system only supports todo/done/blocked statuses. Need cancelled/obsolete status for tickets that are no longer relevant (e.g. TICKET-016 which was superseded by TICKET-019's HTTP server approach).",
      "requirements": [
        "Add 'cancelled' and 'obsolete' as valid ticket status values",
        "Update ticket status validation to accept new statuses",
        "Ensure status filtering works with new statuses"
      ],
      "acceptance_criteria": [
        "Can set ticket status to 'cancelled' or 'obsolete'",
        "List tickets shows cancelled/obsolete tickets appropriately",
        "Status validation accepts new values without breaking existing functionality"
      ],
      "files_affected": [
        "mcp/modules/ticket_manager.py"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    },
    {
      "id": "TICKET-034",
      "title": "Fix UI mockup editor browser send timeout issue",
      "status": "todo",
      "priority": "high",
      "created_at": "2025-09-13T22:12:51Z",
      "updated_at": "2025-09-13T22:12:51Z",
      "description": "UI mockup editor launches browser successfully but fails with \"browser send failed\" timeout after 60 seconds. User can draw but system times out before data transmission completes. Diagram editor works fine with same HTTP server approach, suggesting UI mockup specific issue.",
      "requirements": [
        "Investigate root cause of send failure vs diagram editor",
        "Compare timeout handling between UI mockup and diagram implementations",
        "Determine if timeout duration, data processing, or transmission mechanism differs",
        "Present detailed action plan with specific code locations before implementing fix"
      ],
      "acceptance_criteria": [
        "Root cause analysis completed with findings documented",
        "Action plan presented with specific files/functions to modify",
        "Fix implemented only after action plan approval",
        "UI mockup editor works as reliably as diagram editor",
        "Timeout handling matches or improves upon diagram editor approach"
      ],
      "files_affected": [
        "mcp/modules/diagram_server.py",
        "web/main.js",
        "web/ui.html",
        "web/ui-standalone.html"
      ],
      "dependencies": [],
      "outcome": null,
      "notes": null
    }
  ],
  "templates": {}
}